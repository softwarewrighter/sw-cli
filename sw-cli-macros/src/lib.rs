use proc_macro::TokenStream;
use quote::quote;

/// Returns a formatted version string with build information.
///
/// # Usage
///
/// ```ignore
/// fn main() {
///     if args[1] == "--version" {
///         println!("{}", sw_cli::version!());
///         return;
///     }
/// }
/// ```
///
/// # Output Format (4 lines)
/// ```text
/// Version: 0.1.1
/// Copyright (c) 2025 Your Name
/// MIT License: https://github.com/youruser/repo/blob/main/LICENSE
/// Build: a84bf9a @ hostname (2025-11-22T21:48:21.062+00:00)
/// ```
///
/// Requires `sw_cli::define_build_info!()` to be called in build.rs.
#[proc_macro]
pub fn version(_input: TokenStream) -> TokenStream {
    let expanded = quote! {
        {
            // Include the generated version_info.rs
            mod __version_info {
                include!(concat!(env!("OUT_DIR"), "/version_info.rs"));
            }

            // Construct Version and return formatted string
            let build_info = ::sw_cli::version::BuildInfo::new(
                __version_info::BUILD_HOST.to_string(),
                __version_info::GIT_COMMIT_SHA.to_string(),
                __version_info::BUILD_TIMESTAMP,
            );

            let version_obj = ::sw_cli::version::Version::new(
                __version_info::VERSION.to_string(),
                __version_info::COPYRIGHT.to_string(),
                __version_info::LICENSE_NAME.to_string(),
                __version_info::LICENSE_URL.to_string(),
                build_info,
            );

            format!("{}", version_obj)
        }
    };

    TokenStream::from(expanded)
}

/// Deprecated: Use `version!()` instead.
#[proc_macro]
pub fn create_version(input: TokenStream) -> TokenStream {
    // Keep for backward compatibility but emit deprecation
    version(input)
}

/// Generates version_info.rs with build metadata as const literals.
///
/// This macro should be called in your build.rs file to generate version information.
///
/// # Usage in build.rs
///
/// ```ignore
/// fn main() {
///     sw_cli::define_build_info!();
/// }
/// ```
///
/// # Requirements
/// - COPYRIGHT file in project root
/// - Cargo.toml with version, license, repository fields
///
/// # Generates
/// Creates `$OUT_DIR/version_info.rs` with const literals for runtime use.
/// Always runs on every build (unique timestamp per build).
#[proc_macro]
pub fn define_build_info(_input: TokenStream) -> TokenStream {
    let expanded = quote! {
        {
            use std::process::Command;
            use std::fs;
            use std::path::Path;

            let out_dir = std::env::var("OUT_DIR").expect("OUT_DIR not set");
            let dest_path = Path::new(&out_dir).join("version_info.rs");

            // Read COPYRIGHT file
            let copyright = fs::read_to_string("COPYRIGHT")
                .expect("COPYRIGHT file not found")
                .trim()
                .to_string();

            // Get version from Cargo
            let version = std::env::var("CARGO_PKG_VERSION")
                .expect("CARGO_PKG_VERSION not set");

            // Get license from Cargo
            let license_name = std::env::var("CARGO_PKG_LICENSE")
                .expect("CARGO_PKG_LICENSE not set");

            // Get repository from Cargo
            let repository = std::env::var("CARGO_PKG_REPOSITORY")
                .expect("CARGO_PKG_REPOSITORY not set");
            let license_url = format!("{}/blob/main/LICENSE", repository);

            // Get hostname
            let hostname = Command::new("hostname")
                .output()
                .map(|output| String::from_utf8_lossy(&output.stdout).trim().to_string())
                .unwrap_or_else(|_| "unknown".to_string());

            // Get git commit SHA
            let commit_sha = Command::new("git")
                .args(["rev-parse", "HEAD"])
                .output()
                .map(|output| String::from_utf8_lossy(&output.stdout).trim().to_string())
                .unwrap_or_else(|_| "unknown".to_string());

            // Get build timestamp (always fresh, every build)
            let timestamp = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_millis() as i64;

            // Generate version_info.rs
            let generated_code = format!(
                r#"// Generated by sw_cli::define_build_info!()
// Do not edit manually

pub const VERSION: &str = "{}";
pub const COPYRIGHT: &str = "{}";
pub const LICENSE_NAME: &str = "{}";
pub const LICENSE_URL: &str = "{}";
pub const BUILD_HOST: &str = "{}";
pub const GIT_COMMIT_SHA: &str = "{}";
pub const BUILD_TIMESTAMP: i64 = {};
"#,
                version, copyright, license_name, license_url, hostname, commit_sha, timestamp
            );

            fs::write(&dest_path, generated_code)
                .expect("Failed to write version_info.rs");

            // Always rerun (no rerun-if-changed) - each build gets unique timestamp
        }
    };

    TokenStream::from(expanded)
}
