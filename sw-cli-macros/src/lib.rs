use proc_macro::TokenStream;
use quote::{quote, format_ident};
use syn::{Expr, parse_macro_input, Ident, Type, LitStr, LitChar, Token, parse::{Parse, ParseStream}, punctuated::Punctuated};

/// Returns a formatted version string with build information.
///
/// # Usage
///
/// ```ignore
/// fn main() {
///     if args[1] == "--version" {
///         println!("{}", sw_cli::version!());
///         return;
///     }
/// }
/// ```
///
/// # Output Format (4 lines)
/// ```text
/// Version: 0.1.1
/// Copyright (c) 2025 Your Name
/// MIT License: https://github.com/youruser/repo/blob/main/LICENSE
/// Build: a84bf9a @ hostname (2025-11-22T21:48:21.062+00:00)
/// ```
///
/// Requires `sw_cli::define_build_info!()` to be called in build.rs.
#[proc_macro]
pub fn version(_input: TokenStream) -> TokenStream {
    let expanded = quote! {
        {
            // Include the generated version_info.rs
            mod __version_info {
                include!(concat!(env!("OUT_DIR"), "/version_info.rs"));
            }

            // Construct Version and return formatted string
            let build_info = ::sw_cli::version::BuildInfo::new(
                __version_info::BUILD_HOST.to_string(),
                __version_info::GIT_COMMIT_SHA.to_string(),
                __version_info::BUILD_TIMESTAMP,
            );

            let version_obj = ::sw_cli::version::Version::new(
                __version_info::VERSION.to_string(),
                __version_info::COPYRIGHT.to_string(),
                __version_info::LICENSE_NAME.to_string(),
                __version_info::LICENSE_URL.to_string(),
                build_info,
            );

            format!("{}", version_obj)
        }
    };

    TokenStream::from(expanded)
}

/// Deprecated: Use `version!()` instead.
#[proc_macro]
pub fn create_version(input: TokenStream) -> TokenStream {
    // Keep for backward compatibility but emit deprecation
    version(input)
}

/// Generates `version_info.rs` with build metadata as const literals.
///
/// This macro should be called in your build.rs file to generate version information.
///
/// # Usage in build.rs
///
/// ```ignore
/// fn main() {
///     sw_cli::define_build_info!();
/// }
/// ```
///
/// # Requirements
/// - COPYRIGHT file in project root
/// - Cargo.toml with version, license, repository fields
///
/// # Generates
/// Creates `$OUT_DIR/version_info.rs` with const literals for runtime use.
/// Always runs on every build (unique timestamp per build).
#[proc_macro]
pub fn define_build_info(_input: TokenStream) -> TokenStream {
    let expanded = quote! {
        {
            use std::process::Command;
            use std::fs;
            use std::path::Path;

            let out_dir = std::env::var("OUT_DIR").expect("OUT_DIR not set");
            let dest_path = Path::new(&out_dir).join("version_info.rs");

            // Read COPYRIGHT file
            let copyright = fs::read_to_string("COPYRIGHT")
                .expect("COPYRIGHT file not found")
                .trim()
                .to_string();

            // Get version from Cargo
            let version = std::env::var("CARGO_PKG_VERSION")
                .expect("CARGO_PKG_VERSION not set");

            // Get license from Cargo
            let license_name = std::env::var("CARGO_PKG_LICENSE")
                .expect("CARGO_PKG_LICENSE not set");

            // Get repository from Cargo
            let repository = std::env::var("CARGO_PKG_REPOSITORY")
                .expect("CARGO_PKG_REPOSITORY not set");
            let license_url = format!("{}/blob/main/LICENSE", repository);

            // Get hostname
            let hostname = Command::new("hostname")
                .output()
                .map(|output| String::from_utf8_lossy(&output.stdout).trim().to_string())
                .unwrap_or_else(|_| "unknown".to_string());

            // Get git commit SHA
            let commit_sha = Command::new("git")
                .args(["rev-parse", "HEAD"])
                .output()
                .map(|output| String::from_utf8_lossy(&output.stdout).trim().to_string())
                .unwrap_or_else(|_| "unknown".to_string());

            // Get build timestamp (always fresh, every build)
            let timestamp = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_millis() as i64;

            // Generate version_info.rs
            let generated_code = format!(
                r#"// Generated by sw_cli::define_build_info!()
// Do not edit manually

pub const VERSION: &str = "{}";
pub const COPYRIGHT: &str = "{}";
pub const LICENSE_NAME: &str = "{}";
pub const LICENSE_URL: &str = "{}";
pub const BUILD_HOST: &str = "{}";
pub const GIT_COMMIT_SHA: &str = "{}";
#[allow(clippy::unreadable_literal)]
pub const BUILD_TIMESTAMP: i64 = {};
"#,
                version, copyright, license_name, license_url, hostname, commit_sha, timestamp
            );

            fs::write(&dest_path, generated_code)
                .expect("Failed to write version_info.rs");

            // Always rerun (no rerun-if-changed) - each build gets unique timestamp
        }
    };

    TokenStream::from(expanded)
}

/// Generates `help_info.rs` with help text from src/help.txt or src/short-help.txt and src/long-help.txt files.
///
/// This macro should be called in your build.rs file to generate help information.
///
/// # Usage in build.rs
///
/// ```ignore
/// fn main() {
///     sw_cli::define_build_info!();
///     sw_cli::define_help_info!();
/// }
/// ```
///
/// # Requirements
/// Either:
/// - src/help.txt (used for both short and long help), OR
/// - src/short-help.txt and src/long-help.txt (separate short/long help)
///
/// # Generates
/// Creates `$OUT_DIR/help_info.rs` with const literals for runtime use.
#[proc_macro]
pub fn define_help_info(_input: TokenStream) -> TokenStream {
    let expanded = quote! {
        {
            use std::fs;
            use std::path::Path;

            let out_dir = std::env::var("OUT_DIR").expect("OUT_DIR not set");
            let dest_path = Path::new(&out_dir).join("help_info.rs");

            // Check for help files
            let short_help: String;
            let long_help: String;

            if Path::new("src/help.txt").exists() {
                // Use single help file for both
                let help_content = fs::read_to_string("src/help.txt")
                    .expect("Failed to read src/help.txt")
                    .trim()
                    .to_string();
                short_help = help_content.clone();
                long_help = help_content;
            } else if Path::new("src/short-help.txt").exists() && Path::new("src/long-help.txt").exists() {
                // Use separate short and long help files
                short_help = fs::read_to_string("src/short-help.txt")
                    .expect("Failed to read src/short-help.txt")
                    .trim()
                    .to_string();
                long_help = fs::read_to_string("src/long-help.txt")
                    .expect("Failed to read src/long-help.txt")
                    .trim()
                    .to_string();
            } else {
                panic!("Help files not found. Provide either src/help.txt OR both src/short-help.txt and src/long-help.txt");
            }

            // Generate help_info.rs - escape help strings properly
            let generated_code = format!(
                "// Generated by sw_cli::define_help_info!()\n\
                // Do not edit manually\n\
                \n\
                pub const SHORT_HELP: &str = {:?};\n\
                pub const LONG_HELP: &str = {:?};\n",
                short_help, long_help
            );

            fs::write(&dest_path, generated_code)
                .expect("Failed to write help_info.rs");

            // Rerun if help files change
            println!("cargo:rerun-if-changed=src/help.txt");
            println!("cargo:rerun-if-changed=src/short-help.txt");
            println!("cargo:rerun-if-changed=src/long-help.txt");
        }
    };

    TokenStream::from(expanded)
}

/// Returns the short help text defined in src/help.txt or src/short-help.txt.
///
/// # Usage
///
/// ```ignore
/// println!("{}", sw_cli::short_help!());
/// ```
///
/// Requires `sw_cli::define_help_info!()` to be called in build.rs.
#[proc_macro]
pub fn short_help(_input: TokenStream) -> TokenStream {
    let expanded = quote! {
        {
            mod __help_info {
                include!(concat!(env!("OUT_DIR"), "/help_info.rs"));
            }
            __help_info::SHORT_HELP
        }
    };

    TokenStream::from(expanded)
}

/// Returns the long help text defined in src/help.txt or src/long-help.txt.
///
/// # Usage
///
/// ```ignore
/// println!("{}", sw_cli::long_help!());
/// ```
///
/// Requires `sw_cli::define_help_info!()` to be called in build.rs.
#[proc_macro]
pub fn long_help(_input: TokenStream) -> TokenStream {
    let expanded = quote! {
        {
            mod __help_info {
                include!(concat!(env!("OUT_DIR"), "/help_info.rs"));
            }
            __help_info::LONG_HELP
        }
    };

    TokenStream::from(expanded)
}

/// Simplifies dispatcher creation and command registration.
///
/// # Usage
///
/// ```ignore
/// use sw_cli::dispatch;
///
/// let dispatcher = dispatch!(
///     CountCommand,
///     GrepCommand,
///     ReverseCommand,
///     CopyCommand
/// );
///
/// dispatcher.dispatch(&config)?;
/// ```
///
/// Automatically includes short and long help text from generated `help_info.rs`
/// and registers `VersionCommand` and `HelpCommand` internally.
#[proc_macro]
pub fn dispatch(input: TokenStream) -> TokenStream {
    let commands = parse_macro_input!(input with syn::punctuated::Punctuated::<Expr, syn::Token![,]>::parse_terminated);

    let command_registrations = commands.iter().map(|cmd| {
        quote! { .register(#cmd) }
    });

    let expanded = quote! {
        {
            // Include help_info.rs to get SHORT_HELP and LONG_HELP
            mod __help_info {
                include!(concat!(env!("OUT_DIR"), "/help_info.rs"));
            }

            ::sw_cli::Dispatcher::new(
                __help_info::SHORT_HELP.to_string(),
                __help_info::LONG_HELP.to_string()
            )
                #(#command_registrations)*
        }
    };

    TokenStream::from(expanded)
}

// ====================
// CLI App Builder Macro
// ====================

struct FieldDef {
    name: Ident,
    ty: Type,
    short: Option<char>,
    long: Option<String>,
    help: Option<String>,
    action: Option<String>,
}

impl Parse for FieldDef {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let name: Ident = input.parse()?;
        input.parse::<Token![:]>()?;
        let ty: Type = input.parse()?;

        let mut short = None;
        let mut long = None;
        let mut help = None;
        let mut action = None;

        // Parse optional attributes (comma followed by key = value)
        while input.peek(Token![,]) {
            // Look ahead to see if this is an attribute or next field
            // Attributes: comma, ident, =
            // Next field: comma, ident, :
            let fork = input.fork();
            fork.parse::<Token![,]>()?;
            if fork.peek(Ident) {
                let _test_ident: Ident = fork.parse()?;
                if fork.peek(Token![=]) {
                    // This is an attribute
                    input.parse::<Token![,]>()?;
                    let attr: Ident = input.parse()?;
                    input.parse::<Token![=]>()?;

                    match attr.to_string().as_str() {
                        "short" => {
                            let ch: LitChar = input.parse()?;
                            short = Some(ch.value());
                        }
                        "long" => {
                            let s: LitStr = input.parse()?;
                            long = Some(s.value());
                        }
                        "help" => {
                            let s: LitStr = input.parse()?;
                            help = Some(s.value());
                        }
                        "action" => {
                            let a: Ident = input.parse()?;
                            action = Some(a.to_string());
                        }
                        _ => return Err(syn::Error::new(attr.span(), "unknown attribute")),
                    }
                } else {
                    // Next field, stop parsing attributes
                    break;
                }
            } else {
                break;
            }
        }

        Ok(FieldDef { name, ty, short, long, help, action })
    }
}

struct CliAppInput {
    name: String,
    about: String,
    config_name: Ident,
    fields: Vec<FieldDef>,
}

impl Parse for CliAppInput {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let mut name = None;
        let mut about = None;
        let mut config_name = None;
        let mut fields = Vec::new();

        while !input.is_empty() {
            let key: Ident = input.parse()?;
            input.parse::<Token![:]>()?;

            match key.to_string().as_str() {
                "name" => {
                    let s: LitStr = input.parse()?;
                    name = Some(s.value());
                    input.parse::<Token![,]>()?;
                }
                "about" => {
                    let s: LitStr = input.parse()?;
                    about = Some(s.value());
                    input.parse::<Token![,]>()?;
                }
                "config" => {
                    let id: Ident = input.parse()?;
                    config_name = Some(id);
                    input.parse::<Token![,]>()?;
                }
                "fields" => {
                    let content;
                    syn::braced!(content in input);
                    let parsed_fields = Punctuated::<FieldDef, Token![,]>::parse_terminated(&content)?;
                    fields = parsed_fields.into_iter().collect();
                    if !input.is_empty() {
                        input.parse::<Token![,]>()?;
                    }
                }
                _ => return Err(syn::Error::new(key.span(), "unknown key")),
            }
        }

        Ok(CliAppInput {
            name: name.ok_or_else(|| input.error("missing 'name'"))?,
            about: about.ok_or_else(|| input.error("missing 'about'"))?,
            config_name: config_name.ok_or_else(|| input.error("missing 'config'"))?,
            fields,
        })
    }
}

/// Generates a complete CLI application with config struct, builder, parser, and main function.
///
/// # Usage
///
/// ```ignore
/// cli_app! {
///     name: "my-app",
///     about: "My CLI application",
///     config: MyAppConfig,
///     fields: {
///         input: Option<Vec<PathBuf>>, short = 'i', long = "input", help = "Input files", action = Append,
///         output: Option<PathBuf>, short = 'o', long = "output", help = "Output file",
///         count: bool, long = "count", help = "Count lines",
///     }
/// }
/// ```
///
/// This generates:
/// - Config struct with the specified fields
/// - `build_cli()` function that creates the clap Command
/// - `parse_config()` function that parses ArgMatches into the config
#[proc_macro]
pub fn cli_app(input: TokenStream) -> TokenStream {
    let cli_input = parse_macro_input!(input as CliAppInput);

    let config_name = &cli_input.config_name;
    let app_name = &cli_input.name;
    let app_about = &cli_input.about;

    // Generate config struct fields
    let config_fields = cli_input.fields.iter().map(|f| {
        let name = &f.name;
        let ty = &f.ty;
        quote! { pub #name: #ty }
    });

    // Generate clap args
    let clap_args = cli_input.fields.iter().map(|f| {
        let name_str = f.name.to_string();
        let long = f.long.as_deref().unwrap_or(&name_str);
        let help = f.help.as_deref().unwrap_or("");

        let mut arg = quote! {
            ::clap::Arg::new(#name_str)
                .long(#long)
                .help(#help)
        };

        if let Some(short) = f.short {
            arg = quote! { #arg.short(#short) };
        }

        if let Some(action) = &f.action {
            let action_ident = format_ident!("{}", action);
            arg = quote! { #arg.action(::clap::ArgAction::#action_ident) };
        } else {
            // Determine action based on type
            let ty = &f.ty;
            let ty_string = quote!(#ty).to_string();
            if ty_string.contains("bool") {
                arg = quote! { #arg.action(::clap::ArgAction::SetTrue) };
            } else if ty_string.contains("Vec") {
                arg = quote! { #arg.action(::clap::ArgAction::Append) };
            }
        }

        arg
    });

    // Generate parser for each field
    let field_parsers = cli_input.fields.iter().map(|f| {
        let name = &f.name;
        let name_str = name.to_string();
        let ty = &f.ty;
        let ty_string = quote!(#ty).to_string();

        if ty_string.contains("bool") {
            quote! { #name: matches.get_flag(#name_str) }
        } else if ty_string.contains("Vec") && ty_string.contains("PathBuf") {
            quote! {
                #name: matches.get_many::<String>(#name_str)
                    .map(|vals| vals.map(::std::path::PathBuf::from).collect())
            }
        } else if ty_string.contains("Vec") {
            quote! {
                #name: matches.get_many::<String>(#name_str)
                    .map(|vals| vals.cloned().collect())
            }
        } else if ty_string.contains("PathBuf") {
            quote! { #name: matches.get_one::<String>(#name_str).map(::std::path::PathBuf::from) }
        } else if ty_string.contains("String") {
            quote! { #name: matches.get_one::<String>(#name_str).cloned() }
        } else {
            quote! { #name: matches.get_one(#name_str).cloned() }
        }
    });

    let expanded = quote! {
        #[derive(Debug, Clone)]
        pub struct #config_name {
            pub base: ::sw_cli::BaseConfig,
            #(#config_fields),*
        }

        impl ::sw_cli::CliConfig for #config_name {
            fn base(&self) -> &::sw_cli::BaseConfig {
                &self.base
            }

            fn as_any(&self) -> &dyn ::std::any::Any {
                self
            }
        }

        pub fn build_cli() -> ::clap::Command {
            ::clap::Command::new(#app_name)
                .disable_version_flag(true)
                .disable_help_flag(true)
                .about(#app_about)
                .args(::sw_cli::builder::standard_args())
                #(.arg(#clap_args))*
        }

        pub fn parse_config(matches: &::clap::ArgMatches) -> #config_name {
            #config_name {
                base: ::sw_cli::builder::parse_base_config(matches),
                #(#field_parsers),*
            }
        }
    };

    TokenStream::from(expanded)
}

// ====================
// CLI Command Macro
// ====================

struct CliCommandInput {
    name: Ident,
    config_type: Type,
    can_handle: Expr,
    execute: Expr,
}

impl Parse for CliCommandInput {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let mut name = None;
        let mut config_type = None;
        let mut can_handle = None;
        let mut execute = None;

        while !input.is_empty() {
            let key: Ident = input.parse()?;
            input.parse::<Token![:]>()?;

            match key.to_string().as_str() {
                "name" => {
                    name = Some(input.parse()?);
                    input.parse::<Token![,]>()?;
                }
                "config" => {
                    config_type = Some(input.parse()?);
                    input.parse::<Token![,]>()?;
                }
                "can_handle" => {
                    can_handle = Some(input.parse()?);
                    input.parse::<Token![,]>()?;
                }
                "execute" => {
                    execute = Some(input.parse()?);
                    if !input.is_empty() {
                        input.parse::<Token![,]>()?;
                    }
                }
                _ => return Err(syn::Error::new(key.span(), "unknown key")),
            }
        }

        Ok(CliCommandInput {
            name: name.ok_or_else(|| input.error("missing 'name'"))?,
            config_type: config_type.ok_or_else(|| input.error("missing 'config'"))?,
            can_handle: can_handle.ok_or_else(|| input.error("missing 'can_handle'"))?,
            execute: execute.ok_or_else(|| input.error("missing 'execute'"))?,
        })
    }
}

/// Generates a command implementation with simplified syntax.
///
/// # Usage
///
/// ```ignore
/// cli_command! {
///     name: CountCommand,
///     config: MyAppConfig,
///     can_handle: |config: &MyAppConfig| config.count,
///     execute: |config: &MyAppConfig| {
///         println!("Counting...");
///         Ok(())
///     }
/// }
/// ```
///
/// This generates a struct and Command trait implementation with proper downcasting.
#[proc_macro]
pub fn cli_command(input: TokenStream) -> TokenStream {
    let cmd_input = parse_macro_input!(input as CliCommandInput);

    let name = &cmd_input.name;
    let config_type = &cmd_input.config_type;
    let can_handle_fn = &cmd_input.can_handle;
    let execute_fn = &cmd_input.execute;

    let expanded = quote! {
        pub struct #name;

        impl ::sw_cli::Command for #name {
            fn can_handle(&self, config: &dyn ::sw_cli::CliConfig) -> bool {
                if let Some(cfg) = config.as_any().downcast_ref::<#config_type>() {
                    let handler: fn(&#config_type) -> bool = #can_handle_fn;
                    handler(cfg)
                } else {
                    false
                }
            }

            fn execute(&self, config: &dyn ::sw_cli::CliConfig) -> Result<(), Box<dyn ::std::error::Error>> {
                let cfg = config.as_any()
                    .downcast_ref::<#config_type>()
                    .expect("Config type mismatch");

                let executor: fn(&#config_type) -> Result<(), Box<dyn ::std::error::Error>> = #execute_fn;
                executor(cfg)
            }
        }
    };

    TokenStream::from(expanded)
}
