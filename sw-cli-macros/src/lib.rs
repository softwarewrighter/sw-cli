use proc_macro::TokenStream;
use quote::quote;
use syn::{Expr, parse_macro_input};

/// Returns a formatted version string with build information.
///
/// # Usage
///
/// ```ignore
/// fn main() {
///     if args[1] == "--version" {
///         println!("{}", sw_cli::version!());
///         return;
///     }
/// }
/// ```
///
/// # Output Format (4 lines)
/// ```text
/// Version: 0.1.1
/// Copyright (c) 2025 Your Name
/// MIT License: https://github.com/youruser/repo/blob/main/LICENSE
/// Build: a84bf9a @ hostname (2025-11-22T21:48:21.062+00:00)
/// ```
///
/// Requires `sw_cli::define_build_info!()` to be called in build.rs.
#[proc_macro]
pub fn version(_input: TokenStream) -> TokenStream {
    let expanded = quote! {
        {
            // Include the generated version_info.rs
            mod __version_info {
                include!(concat!(env!("OUT_DIR"), "/version_info.rs"));
            }

            // Construct Version and return formatted string
            let build_info = ::sw_cli::version::BuildInfo::new(
                __version_info::BUILD_HOST.to_string(),
                __version_info::GIT_COMMIT_SHA.to_string(),
                __version_info::BUILD_TIMESTAMP,
            );

            let version_obj = ::sw_cli::version::Version::new(
                __version_info::VERSION.to_string(),
                __version_info::COPYRIGHT.to_string(),
                __version_info::LICENSE_NAME.to_string(),
                __version_info::LICENSE_URL.to_string(),
                build_info,
            );

            format!("{}", version_obj)
        }
    };

    TokenStream::from(expanded)
}

/// Deprecated: Use `version!()` instead.
#[proc_macro]
pub fn create_version(input: TokenStream) -> TokenStream {
    // Keep for backward compatibility but emit deprecation
    version(input)
}

/// Generates `version_info.rs` with build metadata as const literals.
///
/// This macro should be called in your build.rs file to generate version information.
///
/// # Usage in build.rs
///
/// ```ignore
/// fn main() {
///     sw_cli::define_build_info!();
/// }
/// ```
///
/// # Requirements
/// - COPYRIGHT file in project root
/// - Cargo.toml with version, license, repository fields
///
/// # Generates
/// Creates `$OUT_DIR/version_info.rs` with const literals for runtime use.
/// Always runs on every build (unique timestamp per build).
#[proc_macro]
pub fn define_build_info(_input: TokenStream) -> TokenStream {
    let expanded = quote! {
        {
            use std::process::Command;
            use std::fs;
            use std::path::Path;

            let out_dir = std::env::var("OUT_DIR").expect("OUT_DIR not set");
            let dest_path = Path::new(&out_dir).join("version_info.rs");

            // Read COPYRIGHT file
            let copyright = fs::read_to_string("COPYRIGHT")
                .expect("COPYRIGHT file not found")
                .trim()
                .to_string();

            // Get version from Cargo
            let version = std::env::var("CARGO_PKG_VERSION")
                .expect("CARGO_PKG_VERSION not set");

            // Get license from Cargo
            let license_name = std::env::var("CARGO_PKG_LICENSE")
                .expect("CARGO_PKG_LICENSE not set");

            // Get repository from Cargo
            let repository = std::env::var("CARGO_PKG_REPOSITORY")
                .expect("CARGO_PKG_REPOSITORY not set");
            let license_url = format!("{}/blob/main/LICENSE", repository);

            // Get hostname
            let hostname = Command::new("hostname")
                .output()
                .map(|output| String::from_utf8_lossy(&output.stdout).trim().to_string())
                .unwrap_or_else(|_| "unknown".to_string());

            // Get git commit SHA
            let commit_sha = Command::new("git")
                .args(["rev-parse", "HEAD"])
                .output()
                .map(|output| String::from_utf8_lossy(&output.stdout).trim().to_string())
                .unwrap_or_else(|_| "unknown".to_string());

            // Get build timestamp (always fresh, every build)
            let timestamp = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_millis() as i64;

            // Generate version_info.rs
            let generated_code = format!(
                r#"// Generated by sw_cli::define_build_info!()
// Do not edit manually

pub const VERSION: &str = "{}";
pub const COPYRIGHT: &str = "{}";
pub const LICENSE_NAME: &str = "{}";
pub const LICENSE_URL: &str = "{}";
pub const BUILD_HOST: &str = "{}";
pub const GIT_COMMIT_SHA: &str = "{}";
#[allow(clippy::unreadable_literal)]
pub const BUILD_TIMESTAMP: i64 = {};
"#,
                version, copyright, license_name, license_url, hostname, commit_sha, timestamp
            );

            fs::write(&dest_path, generated_code)
                .expect("Failed to write version_info.rs");

            // Always rerun (no rerun-if-changed) - each build gets unique timestamp
        }
    };

    TokenStream::from(expanded)
}

/// Generates `help_info.rs` with help text from src/help.txt or src/short-help.txt and src/long-help.txt files.
///
/// This macro should be called in your build.rs file to generate help information.
///
/// # Usage in build.rs
///
/// ```ignore
/// fn main() {
///     sw_cli::define_build_info!();
///     sw_cli::define_help_info!();
/// }
/// ```
///
/// # Requirements
/// Either:
/// - src/help.txt (used for both short and long help), OR
/// - src/short-help.txt and src/long-help.txt (separate short/long help)
///
/// # Generates
/// Creates `$OUT_DIR/help_info.rs` with const literals for runtime use.
#[proc_macro]
pub fn define_help_info(_input: TokenStream) -> TokenStream {
    let expanded = quote! {
        {
            use std::fs;
            use std::path::Path;

            let out_dir = std::env::var("OUT_DIR").expect("OUT_DIR not set");
            let dest_path = Path::new(&out_dir).join("help_info.rs");

            // Check for help files
            let short_help: String;
            let long_help: String;

            if Path::new("src/help.txt").exists() {
                // Use single help file for both
                let help_content = fs::read_to_string("src/help.txt")
                    .expect("Failed to read src/help.txt")
                    .trim()
                    .to_string();
                short_help = help_content.clone();
                long_help = help_content;
            } else if Path::new("src/short-help.txt").exists() && Path::new("src/long-help.txt").exists() {
                // Use separate short and long help files
                short_help = fs::read_to_string("src/short-help.txt")
                    .expect("Failed to read src/short-help.txt")
                    .trim()
                    .to_string();
                long_help = fs::read_to_string("src/long-help.txt")
                    .expect("Failed to read src/long-help.txt")
                    .trim()
                    .to_string();
            } else {
                panic!("Help files not found. Provide either src/help.txt OR both src/short-help.txt and src/long-help.txt");
            }

            // Generate help_info.rs - escape help strings properly
            let generated_code = format!(
                "// Generated by sw_cli::define_help_info!()\n\
                // Do not edit manually\n\
                \n\
                pub const SHORT_HELP: &str = {:?};\n\
                pub const LONG_HELP: &str = {:?};\n",
                short_help, long_help
            );

            fs::write(&dest_path, generated_code)
                .expect("Failed to write help_info.rs");

            // Rerun if help files change
            println!("cargo:rerun-if-changed=src/help.txt");
            println!("cargo:rerun-if-changed=src/short-help.txt");
            println!("cargo:rerun-if-changed=src/long-help.txt");
        }
    };

    TokenStream::from(expanded)
}

/// Returns the short help text defined in src/help.txt or src/short-help.txt.
///
/// # Usage
///
/// ```ignore
/// println!("{}", sw_cli::short_help!());
/// ```
///
/// Requires `sw_cli::define_help_info!()` to be called in build.rs.
#[proc_macro]
pub fn short_help(_input: TokenStream) -> TokenStream {
    let expanded = quote! {
        {
            mod __help_info {
                include!(concat!(env!("OUT_DIR"), "/help_info.rs"));
            }
            __help_info::SHORT_HELP
        }
    };

    TokenStream::from(expanded)
}

/// Returns the long help text defined in src/help.txt or src/long-help.txt.
///
/// # Usage
///
/// ```ignore
/// println!("{}", sw_cli::long_help!());
/// ```
///
/// Requires `sw_cli::define_help_info!()` to be called in build.rs.
#[proc_macro]
pub fn long_help(_input: TokenStream) -> TokenStream {
    let expanded = quote! {
        {
            mod __help_info {
                include!(concat!(env!("OUT_DIR"), "/help_info.rs"));
            }
            __help_info::LONG_HELP
        }
    };

    TokenStream::from(expanded)
}

/// Simplifies dispatcher creation and command registration.
///
/// # Usage
///
/// ```ignore
/// use sw_cli::dispatch;
///
/// let dispatcher = dispatch!(
///     CountCommand,
///     GrepCommand,
///     ReverseCommand,
///     CopyCommand
/// );
///
/// dispatcher.dispatch(&config)?;
/// ```
///
/// Automatically includes short and long help text from generated `help_info.rs`
/// and registers `VersionCommand` and `HelpCommand` internally.
#[proc_macro]
pub fn dispatch(input: TokenStream) -> TokenStream {
    let commands = parse_macro_input!(input with syn::punctuated::Punctuated::<Expr, syn::Token![,]>::parse_terminated);

    let command_registrations = commands.iter().map(|cmd| {
        quote! { .register(#cmd) }
    });

    let expanded = quote! {
        {
            // Include help_info.rs to get SHORT_HELP and LONG_HELP
            mod __help_info {
                include!(concat!(env!("OUT_DIR"), "/help_info.rs"));
            }

            ::sw_cli::Dispatcher::new(
                __help_info::SHORT_HELP.to_string(),
                __help_info::LONG_HELP.to_string()
            )
                #(#command_registrations)*
        }
    };

    TokenStream::from(expanded)
}
