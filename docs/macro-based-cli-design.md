# Macro-Based CLI Framework Design

## Vision: Ultra-Concise CLI Creation

The goal is to reduce CLI creation to its essence using macros, traits, and the chain of responsibility pattern. Every CLI should have a main.rs that looks like this:

```rust
use sw_cli::prelude::*;

// Define your CLI-specific config and commands in ~20 lines
cli_app! {
    name: "my-tool",
    about: "Does amazing things",

    // Custom arguments beyond the standard -v, -n, -h, -V, -q, -i, -o
    args: {
        pattern: String => (long = "pattern", short = 'p', help = "Pattern to match"),
        count: bool => (long = "count", help = "Count occurrences"),
        reverse: bool => (long = "reverse", help = "Reverse output"),
    },

    // Commands that handle your CLI logic
    commands: [
        CountCommand,
        ReverseCommand,
        ProcessCommand,  // default
    ]
}
```

That's it. The macro generates everything else.

## Architecture: Three-Layer Design

### Layer 1: Base Config (Common to ALL CLIs)

Every CLI needs these standard flags:

```rust
pub struct BaseConfig {
    // Standard POSIX-style flags
    pub verbose: bool,      // -v, --verbose
    pub dry_run: bool,      // -n, --dry-run
    pub quiet: bool,        // -q, --quiet
    pub force: bool,        // -f, --force
    pub help: bool,         // -h, --help
    pub version: bool,      // -V, --version

    // Standard I/O
    pub input: Option<Vec<PathBuf>>,   // -i, --input (multiple)
    pub output: Option<PathBuf>,        // -o, --output
    pub append: bool,                   // -a, --append
}
```

### Layer 2: CLI-Specific Config (Extends BaseConfig)

```rust
// Generated by cli_app! macro
pub struct MyToolConfig {
    pub base: BaseConfig,      // Standard flags

    // Custom fields from macro's args block
    pub pattern: Option<String>,
    pub count: bool,
    pub reverse: bool,
}
```

### Layer 3: Commands (Chain of Responsibility)

```rust
pub trait Command {
    fn can_handle(&self, config: &dyn CliConfig) -> bool;
    fn execute(&self, config: &dyn CliConfig) -> Result<(), Box<dyn Error>>;
    fn priority(&self) -> u8 { 100 } // Lower = higher priority
}
```

## The Macro System

### 1. `cli_app!` - Main Macro

Generates:
- Custom config struct (extends BaseConfig)
- Clap command builder with standard + custom args
- Config parser from ArgMatches
- Main function with dispatcher setup

```rust
cli_app! {
    name: "my-tool",
    about: "Tool description",

    args: {
        // field_name: Type => (clap attributes)
        pattern: String => (long = "pattern", short = 'p', help = "Pattern"),
        count: bool => (long = "count", help = "Count matches"),
    },

    commands: [
        CountCommand,      // Handles --count
        ProcessCommand,    // Default handler
    ]
}
```

**Expands to:**

```rust
// Config struct
pub struct MyToolConfig {
    pub base: BaseConfig,
    pub pattern: Option<String>,
    pub count: bool,
}

impl CliConfig for MyToolConfig {
    fn base(&self) -> &BaseConfig { &self.base }
    fn wants_help(&self) -> bool { self.base.help }
    fn wants_version(&self) -> bool { self.base.version }
    fn verbosity(&self) -> u8 { if self.base.verbose { 1 } else { 0 } }
    fn is_dry_run(&self) -> bool { self.base.dry_run }
}

// Builder
fn build_cli() -> clap::Command {
    use clap::{Command, Arg};

    Command::new("my-tool")
        .about("Tool description")
        // Standard flags (added by macro)
        .arg(Arg::new("verbose").short('v').long("verbose"))
        .arg(Arg::new("dry-run").short('n').long("dry-run"))
        .arg(Arg::new("quiet").short('q').long("quiet"))
        .arg(Arg::new("force").short('f').long("force"))
        .arg(Arg::new("help").short('h').long("help"))
        .arg(Arg::new("version").short('V').long("version"))
        .arg(Arg::new("input").short('i').long("input").action(ArgAction::Append))
        .arg(Arg::new("output").short('o').long("output"))
        .arg(Arg::new("append").short('a').long("append"))
        // Custom args (from macro)
        .arg(Arg::new("pattern").short('p').long("pattern"))
        .arg(Arg::new("count").long("count").action(ArgAction::SetTrue))
}

// Parser
fn parse_config(matches: clap::ArgMatches) -> MyToolConfig {
    MyToolConfig {
        base: BaseConfig {
            verbose: matches.get_flag("verbose"),
            dry_run: matches.get_flag("dry-run"),
            quiet: matches.get_flag("quiet"),
            force: matches.get_flag("force"),
            help: matches.get_flag("help"),
            version: matches.get_flag("version"),
            input: matches.get_many("input").map(|v| v.cloned().collect()),
            output: matches.get_one("output").cloned(),
            append: matches.get_flag("append"),
        },
        pattern: matches.get_one("pattern").cloned(),
        count: matches.get_flag("count"),
    }
}

// Main function
fn main() {
    let matches = build_cli().get_matches();
    let config = parse_config(matches);

    // Create dispatcher with priority chain
    let dispatcher = Dispatcher::new()
        .register(VersionCommand::new())      // Priority 0
        .register(HelpCommand::new())         // Priority 1
        .register(CountCommand)               // Priority 100
        .register(ProcessCommand);            // Priority 100

    if let Err(e) = dispatcher.dispatch(&config) {
        eprintln!("Error: {}", e);
        std::process::exit(1);
    }
}
```

### 2. `cli_command!` - Command Definition Macro

Simplifies command implementation:

```rust
cli_command! {
    name: CountCommand,
    priority: 100,

    can_handle: |config: &MyToolConfig| {
        config.count
    },

    execute: |config: &MyToolConfig| {
        let inputs = config.base.input.as_ref()
            .ok_or("No input files specified")?;

        for path in inputs {
            if config.is_dry_run() {
                println!("Would count lines in: {}", path.display());
                continue;
            }

            let file = std::fs::File::open(path)?;
            let reader = std::io::BufReader::new(file);
            let count = reader.lines().count();

            if config.verbosity() > 0 {
                println!("{}: {} lines", path.display(), count);
            } else {
                println!("{}", count);
            }
        }

        Ok(())
    }
}
```

**Expands to:**

```rust
pub struct CountCommand;

impl Command for CountCommand {
    fn can_handle(&self, config: &dyn CliConfig) -> bool {
        let config = config.as_any()
            .downcast_ref::<MyToolConfig>()
            .expect("Invalid config type");
        config.count
    }

    fn execute(&self, config: &dyn CliConfig) -> Result<(), Box<dyn Error>> {
        let config = config.as_any()
            .downcast_ref::<MyToolConfig>()
            .expect("Invalid config type");

        // ... execute block from macro
    }

    fn priority(&self) -> u8 { 100 }
}
```

## Built-in Commands (Provided by sw-cli)

### VersionCommand (Priority 0)

```rust
pub struct VersionCommand {
    version_string: String,
}

impl VersionCommand {
    pub fn new() -> Self {
        Self {
            version_string: version!(), // Uses existing macro
        }
    }
}

impl Command for VersionCommand {
    fn can_handle(&self, config: &dyn CliConfig) -> bool {
        config.wants_version()
    }

    fn execute(&self, config: &dyn CliConfig) -> Result<(), Box<dyn Error>> {
        println!("{}", self.version_string);
        Ok(())
    }

    fn priority(&self) -> u8 { 0 }  // Highest priority
}
```

### HelpCommand (Priority 1)

```rust
pub struct HelpCommand {
    help_text: String,
}

impl HelpCommand {
    pub fn new(help_text: String) -> Self {
        Self { help_text }
    }
}

impl Command for HelpCommand {
    fn can_handle(&self, config: &dyn CliConfig) -> bool {
        config.wants_help()
    }

    fn execute(&self, config: &dyn CliConfig) -> Result<(), Box<dyn Error>> {
        println!("{}", self.help_text);
        Ok(())
    }

    fn priority(&self) -> u8 { 1 }
}
```

## Dispatcher Implementation

```rust
pub struct Dispatcher {
    commands: Vec<Box<dyn Command>>,
}

impl Dispatcher {
    pub fn new() -> Self {
        Self { commands: Vec::new() }
    }

    pub fn register<C: Command + 'static>(mut self, command: C) -> Self {
        self.commands.push(Box::new(command));
        // Sort by priority after each registration
        self.commands.sort_by_key(|c| c.priority());
        self
    }

    pub fn dispatch(&self, config: &dyn CliConfig) -> Result<(), Box<dyn Error>> {
        // Chain of responsibility: try each command in priority order
        for command in &self.commands {
            if command.can_handle(config) {
                return command.execute(config);
            }
        }

        Err("No command could handle this request".into())
    }
}
```

## Trait Hierarchy

```rust
/// Base trait for all CLI configs
pub trait CliConfig: Any {
    fn base(&self) -> &BaseConfig;
    fn wants_help(&self) -> bool { self.base().help }
    fn wants_version(&self) -> bool { self.base().version }
    fn verbosity(&self) -> u8 {
        if self.base().quiet { 0 }
        else if self.base().verbose { 1 }
        else { 0 }
    }
    fn is_dry_run(&self) -> bool { self.base().dry_run }

    // Enable downcasting
    fn as_any(&self) -> &dyn Any;
}

/// Command that can execute CLI logic
pub trait Command {
    fn can_handle(&self, config: &dyn CliConfig) -> bool;
    fn execute(&self, config: &dyn CliConfig) -> Result<(), Box<dyn Error>>;
    fn priority(&self) -> u8 { 100 }  // Default priority
    fn name(&self) -> &str { "unknown" }
}
```

## Complete Example: Minimal CLI

Here's what a complete CLI looks like with this design:

```rust
// main.rs
use sw_cli::prelude::*;

cli_app! {
    name: "file-processor",
    version: "0.1.0",
    about: "Processes files with various operations",

    args: {
        pattern: String => (short = 'p', long = "pattern", help = "Pattern to match"),
        count: bool => (long = "count", help = "Count lines"),
        reverse: bool => (long = "reverse", help = "Reverse lines"),
    },

    commands: [
        CountCommand,
        ReverseCommand,
        ProcessCommand,  // default
    ]
}

// Commands can be in separate modules
cli_command! {
    name: CountCommand,

    can_handle: |config: &FileProcessorConfig| config.count,

    execute: |config: &FileProcessorConfig| {
        count_lines(config)
    }
}

cli_command! {
    name: ReverseCommand,

    can_handle: |config: &FileProcessorConfig| config.reverse,

    execute: |config: &FileProcessorConfig| {
        reverse_lines(config)
    }
}

cli_command! {
    name: ProcessCommand,

    can_handle: |_config: &FileProcessorConfig| true,  // Default handler

    execute: |config: &FileProcessorConfig| {
        process_files(config)
    }
}

// Implementation functions
fn count_lines(config: &FileProcessorConfig) -> CliResult {
    // Implementation...
}

fn reverse_lines(config: &FileProcessorConfig) -> CliResult {
    // Implementation...
}

fn process_files(config: &FileProcessorConfig) -> CliResult {
    // Implementation...
}
```

That's it! The entire CLI in one file, with clear separation of concerns.

## Benefits

1. **Concise**: Main CLI definition is ~15 lines
2. **Type-safe**: Config is strongly typed, no string keys
3. **Extensible**: Add commands by registering them
4. **Testable**: Each command is a separate struct
5. **Reusable**: Standard flags and behavior shared across all CLIs
6. **Clear**: Chain of responsibility makes dispatch logic obvious
7. **No boilerplate**: Macro generates all the clap/parsing code

## Implementation Priority

1. **Phase 1**: BaseConfig, CliConfig trait, Command trait, Dispatcher
2. **Phase 2**: Built-in VersionCommand and HelpCommand
3. **Phase 3**: `cli_app!` macro (generates config + builder + parser + main)
4. **Phase 4**: `cli_command!` macro (simplifies command creation)
5. **Phase 5**: Additional helpers (input/output handling, etc.)

## Migration Path

Existing version-only CLIs continue to work:

```rust
// Old way (still works)
fn main() {
    if args[1] == "--version" {
        println!("{}", sw_cli::version!());
    }
}

// New way (with full framework)
cli_app! {
    name: "my-cli",
    commands: []  // Only version and help
}
```
